<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nero&#39;s Nodes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-06-29T13:33:33.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Nero</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>swift初始化笔记</title>
    <link href="http://yoursite.com/2016/06/28/swift_initializers/"/>
    <id>http://yoursite.com/2016/06/28/swift_initializers/</id>
    <published>2016-06-27T16:00:00.000Z</published>
    <updated>2016-06-29T13:33:33.000Z</updated>
    
    <content type="html">&lt;p&gt;今天复习无聊，就在segmentfault上注册了个账号，然后看到了&lt;a href=&quot;https://segmentfault.com/q/1010000005792852?_ea=912951&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个&lt;/a&gt;关于swift初始化的问题，以前有仔细看过，就去尝试得回答了一下，但是发现好像都忘了，然后重看了一下。还是应该做好笔记什么的比较好。这篇文章就准备写一下swift的初始化过程，当做笔记。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;默认构造器-和-结构体的逐一成员构造器&quot;&gt;&lt;a href=&quot;#默认构造器-和-结构体的逐一成员构造器&quot; class=&quot;headerlink&quot; title=&quot;默认构造器 和 结构体的逐一成员构造器&quot;&gt;&lt;/a&gt;默认构造器 和 结构体的逐一成员构造器&lt;/h2&gt;&lt;p&gt;如果一个class或struct提供了默认值，同时没有定义任何构造器那么会自动提供一个默认构造器(default initializers)。如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Person {
    var firstName = &amp;quot;Nero&amp;quot;
    var lastName = &amp;quot;Zuo&amp;quot;
}
let person = Person()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结构体的逐一成员构造器，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct Circle {
    var center: CGPoint = CGPoint(x: 0, y: 2)
    var radius: CGFloat = 2
}

let circle0 = Circle(center: CGPoint(x: 0, y: 0), radius: 1) //逐一成员构造器
let circle1 = Circle() //默认构造器
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;指定构造器-Designated-和便利构造器-Convenience&quot;&gt;&lt;a href=&quot;#指定构造器-Designated-和便利构造器-Convenience&quot; class=&quot;headerlink&quot; title=&quot;指定构造器(Designated)和便利构造器(Convenience)&quot;&gt;&lt;/a&gt;指定构造器(Designated)和便利构造器(Convenience)&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Shape {
    var lineWidth: CGFloat
    init(lineWidth: CGFloat) {
        self.lineWidth = lineWidth
    }

    convenience init() {
        self.init(lineWidth: 1)
    }   
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里&lt;code&gt;init(lineWidth: CGFloat)&lt;/code&gt;是指定构造器，&lt;code&gt;convenience init()&lt;/code&gt;是便利构造器，使用&lt;code&gt;convenience&lt;/code&gt;关键字&lt;/p&gt;
&lt;h3 id=&quot;继承中的构造器&quot;&gt;&lt;a href=&quot;#继承中的构造器&quot; class=&quot;headerlink&quot; title=&quot;继承中的构造器&quot;&gt;&lt;/a&gt;继承中的构造器&lt;/h3&gt;&lt;h4 id=&quot;自动继承构造器&quot;&gt;&lt;a href=&quot;#自动继承构造器&quot; class=&quot;headerlink&quot; title=&quot;自动继承构造器&quot;&gt;&lt;/a&gt;自动继承构造器&lt;/h4&gt;&lt;p&gt; 如果子类没有写任何指定构造器，那么子类就继承继承父类的所有构造器，包括便利构造器，同时你可以增加遍历构造器但不用重写指定构造器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Shape {
    var lineWidth: CGFloat
    init(lineWidth: CGFloat) {
        self.lineWidth = lineWidth
    }

    convenience init() {
        self.init(lineWidth: 1)
    }
}

class Circle: Shape {
    convenience init(value: Int) {
        self.init()
        //self.init(lineWidth: 1) //这同样可以
    }
}

let circle0 = Circle()
let circle1 = Circle(lineWidth: 2)
let circle2 = circle(value: 1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;便利构造器一定要调用&lt;em&gt;self&lt;/em&gt;的构造的，而不是&lt;em&gt;super&lt;/em&gt;。这里看真好像调用了&lt;em&gt;super&lt;/em&gt;的，但是这里&lt;em&gt;Circle&lt;/em&gt;类自动继承了父类的所有构造器。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果子类把所有的指定构造器重写了，那么父类的便利构造器也会自动继承&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Shape {
    var lineWidth: CGFloat
    init(lineWidth: CGFloat) {
        self.lineWidth = lineWidth
    }

    convenience init() {
        self.init(lineWidth: 1)
    }
}

class Circle: Shape {

    var radius: CGFloat

    init(radius: CGFloat) {
        self.radius = radius
        super.init(lineWidth: 2)
    }

    override init(lineWidth: CGFloat) {
        self.radius = 2
        super.init(lineWidth: lineWidth)
    }

}

let circle0 = Circle(lineWidth: 1) //成功
let circle1 = Circle() //成功，父类的便利构造器继承下来了
let circle2 = Circle(radius: 1) //成功
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里举得例子不是很好，但能说明自动继承，和下面的那段类似代码对比看更好。&lt;/p&gt;
&lt;h4 id=&quot;构造器的继承和重写&quot;&gt;&lt;a href=&quot;#构造器的继承和重写&quot; class=&quot;headerlink&quot; title=&quot;构造器的继承和重写&quot;&gt;&lt;/a&gt;构造器的继承和重写&lt;/h4&gt;&lt;p&gt;当你定义了一个的新的构造器时，那么在此构造器你必须新调用父类的指定构造器（待会儿说道构造过程时会具体讲到）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Shape {
    var lineWidth: CGFloat
    init(lineWidth: CGFloat) {
        self.lineWidth = lineWidth
    }

    convenience init() {
        self.init(lineWidth: 1)
    }
}


class Circle: Shape {
    var radius: CGFloat

    init(radius: CGFloat) {
        self.radius = radius
        super.init(lineWidth: 2)
    }
}

let circle0 = Circle(lineWidth: 1) //错误，不能初始化，因为没有重写
let circle1 = Circle() //错误，不能初始化
let circle2 = Circle(radius: CGFloat) //成功
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的父类的&lt;code&gt;init(lineWidth: CGFloat)&lt;/code&gt;和&lt;code&gt;convenience init()&lt;/code&gt;都不能在子类里用了，因为没有重写。&lt;/p&gt;
&lt;p&gt;重写构造器只能重写父类的指定的构造器，加上关键字&lt;code&gt;override&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;两段式构造过程&quot;&gt;&lt;a href=&quot;#两段式构造过程&quot; class=&quot;headerlink&quot; title=&quot;两段式构造过程&quot;&gt;&lt;/a&gt;两段式构造过程&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://nero5023.github.io/images/initializerDelegation.png&quot; alt=&quot;initializer&quot;&gt;&lt;/p&gt;
&lt;h6 id=&quot;第一阶段：&quot;&gt;&lt;a href=&quot;#第一阶段：&quot; class=&quot;headerlink&quot; title=&quot;第一阶段：&quot;&gt;&lt;/a&gt;第一阶段：&lt;/h6&gt;&lt;p&gt;我的理解是类似不断递归的过程，最下面的子类给自己新的存储属性赋值，然后调用父类的指定构造器（不能调用父类的便利构造器），父类的构造器也是这个过程，不断往上，打到最上面时结束&lt;/p&gt;
&lt;h6 id=&quot;第二阶段：&quot;&gt;&lt;a href=&quot;#第二阶段：&quot; class=&quot;headerlink&quot; title=&quot;第二阶段：&quot;&gt;&lt;/a&gt;第二阶段：&lt;/h6&gt;&lt;p&gt;此时可以使用&lt;code&gt;self&lt;/code&gt;，从上到下对对属性进一步定制化。&lt;/p&gt;
&lt;p&gt;一句话总结指定构造器和便利构造器是指定构造器纵向代理，遍历构造器横向代理&lt;/p&gt;
&lt;h2 id=&quot;必要构造器-Required&quot;&gt;&lt;a href=&quot;#必要构造器-Required&quot; class=&quot;headerlink&quot; title=&quot;必要构造器(Required)&quot;&gt;&lt;/a&gt;必要构造器(Required)&lt;/h2&gt;&lt;p&gt;如果子类中重写或定义了指定构造器，就必须在子类中实现这个必要构造器，且不需要加上&lt;code&gt;override&lt;/code&gt;关键字，只需要加上&lt;code&gt;required&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;遇到最多的就是必要构造器就是&lt;code&gt;required init?(coder aDecoder: NSCoder)&lt;/code&gt;&lt;br&gt;这个在iOS中，如UIView, UIViewController等中经常出现，遵循了&lt;code&gt;NSCoding&lt;/code&gt;协议，用于归档转码等。&lt;/p&gt;
&lt;h2 id=&quot;可失败构造器&quot;&gt;&lt;a href=&quot;#可失败构造器&quot; class=&quot;headerlink&quot; title=&quot;可失败构造器&quot;&gt;&lt;/a&gt;可失败构造器&lt;/h2&gt;&lt;p&gt;类似这样的是可失败构造器，这个返回的是这个类的optional。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;init?(){ }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;浅见觉得调用这个（便利或指定）的构造器都需要是可失败构造器&lt;/p&gt;
&lt;p&gt;第一次写技术类的博客，有点生硬，多写写应该会好些。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天复习无聊，就在segmentfault上注册了个账号，然后看到了&lt;a href=&quot;https://segmentfault.com/q/1010000005792852?_ea=912951&quot;&gt;这个&lt;/a&gt;关于swift初始化的问题，以前有仔细看过，就去尝试得回答了一下，但是发现好像都忘了，然后重看了一下。还是应该做好笔记什么的比较好。这篇文章就准备写一下swift的初始化过程，当做笔记。&lt;br&gt;
    
    </summary>
    
      <category term="iOS Develop" scheme="http://yoursite.com/categories/iOS-Develop/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swfit" scheme="http://yoursite.com/tags/Swfit/"/>
    
      <category term="初始化" scheme="http://yoursite.com/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>版本控制及版本号的应用</title>
    <link href="http://yoursite.com/2016/06/27/git-flow_and_semantic_versioning/"/>
    <id>http://yoursite.com/2016/06/27/git-flow_and_semantic_versioning/</id>
    <published>2016-06-26T16:00:00.000Z</published>
    <updated>2016-06-29T10:37:24.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;语义化版本-Semantic-Versioning&quot;&gt;&lt;a href=&quot;#语义化版本-Semantic-Versioning&quot; class=&quot;headerlink&quot; title=&quot;语义化版本 Semantic Versioning&quot;&gt;&lt;/a&gt;语义化版本 Semantic Versioning&lt;/h3&gt;&lt;p&gt;今天复习毛概，好无聊，就找了昨天看swift package manager上面有一个&lt;a href=&quot;http://semver.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Semantic Versioning（语义化版本）&lt;/a&gt;的链接，讲了些版本号的格式，作用。原来对这版本号不是很了解，觉得这个东西蛮主观的，但现在发现原来还有这么大的用处，觉得这个可以很好地管理项目且很好理解。&lt;/p&gt;
&lt;p&gt;版本格式：主版本号.次版本号.修订号 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主版本号：当你做了不兼容的 API 修改，&lt;/li&gt;
&lt;li&gt;次版本号：当你做了向下兼容的功能性新增，&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修订号：当你做了向下兼容的问题修正。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;注意点：（x.y.z）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;禁止在数字前方补零，如01&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;处于开发初始阶段时候用0.y.z，1.0.0&lt;/li&gt;
&lt;li&gt;y增加时，z归0。x增加时，y,z归0。&lt;/li&gt;
&lt;li&gt;修订号 Z（x.y.Z | x &amp;gt; 0）“必须 MUST ”在只做了向下兼容的修正时才递增。&lt;/li&gt;
&lt;li&gt;次版本号 Y（x.Y.z | x &amp;gt; 0）“必须 MUST ”在有向下兼容的新功能出现时递增。&lt;/li&gt;
&lt;li&gt;主版本号 X（X.y.z | X &amp;gt; 0）“必须 MUST ”在有任何不兼容的修改被加入公共 API 时递增。在任何公共 API 的功能被标记为弃用时也“必须 MUST ”递增。&lt;/li&gt;
&lt;li&gt;其他详见链接里面&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Git-Flow&quot;&gt;&lt;a href=&quot;#Git-Flow&quot; class=&quot;headerlink&quot; title=&quot;Git Flow&quot;&gt;&lt;/a&gt;Git Flow&lt;/h3&gt;&lt;p&gt;去参加WWDC期间，晚上和舍友Adam聊到了git，我说我自己用git就一条分支，觉得没有真正发挥git的强大之处，然后他就推荐给我了git flow，到了现在才看，惭愧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git flow&lt;/a&gt;是一个基于git的管理解决方案，是git的扩展集&lt;/p&gt;
&lt;h4 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;git flow init //原来已经有git或没有都可以
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;特性-Feature&quot;&gt;&lt;a href=&quot;#特性-Feature&quot; class=&quot;headerlink&quot; title=&quot;特性 Feature&quot;&gt;&lt;/a&gt;特性 Feature&lt;/h4&gt;&lt;h5 id=&quot;增加新特性&quot;&gt;&lt;a href=&quot;#增加新特性&quot; class=&quot;headerlink&quot; title=&quot;增加新特性&quot;&gt;&lt;/a&gt;增加新特性&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;git flow feature start MYFEATURE
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;完成新特性&quot;&gt;&lt;a href=&quot;#完成新特性&quot; class=&quot;headerlink&quot; title=&quot;完成新特性&quot;&gt;&lt;/a&gt;完成新特性&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;git flow feature finish MYFEATURE
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;发布新特性&quot;&gt;&lt;a href=&quot;#发布新特性&quot; class=&quot;headerlink&quot; title=&quot;发布新特性&quot;&gt;&lt;/a&gt;发布新特性&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;git flow feature publish MYFEATURE
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;Release-版本&quot;&gt;&lt;a href=&quot;#Release-版本&quot; class=&quot;headerlink&quot; title=&quot;Release 版本&quot;&gt;&lt;/a&gt;Release 版本&lt;/h4&gt;&lt;h5 id=&quot;开始准备release版本&quot;&gt;&lt;a href=&quot;#开始准备release版本&quot; class=&quot;headerlink&quot; title=&quot;开始准备release版本&quot;&gt;&lt;/a&gt;开始准备release版本&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;git flow release start TAG // TAG如1.2.0
-------------------------------------------
git flow release publish TAG // 这是发布
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;完成-release-版本&quot;&gt;&lt;a href=&quot;#完成-release-版本&quot; class=&quot;headerlink&quot; title=&quot;完成 release 版本&quot;&gt;&lt;/a&gt;完成 release 版本&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;git flow release finish TAG
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;紧急修复-hotfix&quot;&gt;&lt;a href=&quot;#紧急修复-hotfix&quot; class=&quot;headerlink&quot; title=&quot;紧急修复 hotfix&quot;&gt;&lt;/a&gt;紧急修复 hotfix&lt;/h4&gt;&lt;h5 id=&quot;开始修复&quot;&gt;&lt;a href=&quot;#开始修复&quot; class=&quot;headerlink&quot; title=&quot;开始修复&quot;&gt;&lt;/a&gt;开始修复&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;git flow hotfix start VERSION // VERSION 如1.2.1
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;完成修复&quot;&gt;&lt;a href=&quot;#完成修复&quot; class=&quot;headerlink&quot; title=&quot;完成修复&quot;&gt;&lt;/a&gt;完成修复&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;git flow hotfix finish VERSION
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外SourceTree上面很好的支持了Git Flow，所以只要了解其工作原理就行了，不必完全记住命令。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;语义化版本-Semantic-Versioning&quot;&gt;&lt;a href=&quot;#语义化版本-Semantic-Versioning&quot; class=&quot;headerlink&quot; title=&quot;语义化版本 Semantic Versioning&quot;&gt;&lt;/a&gt;语义化版本 Semantic Versioning&lt;/h3&gt;&lt;p&gt;今天复习毛概，好无聊，就找了昨天看swift package manager上面有一个&lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning（语义化版本）&lt;/a&gt;的链接，讲了些版本号的格式，作用。原来对这版本号不是很了解，觉得这个东西蛮主观的，但现在发现原来还有这么大的用处，觉得这个可以很好地管理项目且很好理解。&lt;/p&gt;
&lt;p&gt;版本格式：主版本号.次版本号.修订号 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主版本号：当你做了不兼容的 API 修改，&lt;/li&gt;
&lt;li&gt;次版本号：当你做了向下兼容的功能性新增，&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修订号：当你做了向下兼容的问题修正。&lt;/p&gt;
    
    </summary>
    
      <category term="项目管理" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="Semantic Versioning" scheme="http://yoursite.com/tags/Semantic-Versioning/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>我是如何申请到Apple WWDC Scholarship</title>
    <link href="http://yoursite.com/2016/06/07/wwdcScholarshipExperience/"/>
    <id>http://yoursite.com/2016/06/07/wwdcScholarshipExperience/</id>
    <published>2016-06-07T12:46:25.000Z</published>
    <updated>2016-06-29T13:35:34.000Z</updated>
    
    <content type="html">&lt;p&gt;我现在是苏州大学计科院物联网工程大二的学生。在这篇文章中我将分享我学习 iOS 的历程，独立开发app并成功申请到 Apple WWDC Scholarship 的故事，以及一些个人感悟。&lt;/p&gt;
&lt;h2 id=&quot;学习历程&quot;&gt;&lt;a href=&quot;#学习历程&quot; class=&quot;headerlink&quot; title=&quot;学习历程&quot;&gt;&lt;/a&gt;学习历程&lt;/h2&gt;&lt;h3 id=&quot;里程碑一：有自己的想法&quot;&gt;&lt;a href=&quot;#里程碑一：有自己的想法&quot; class=&quot;headerlink&quot; title=&quot;里程碑一：有自己的想法&quot;&gt;&lt;/a&gt;里程碑一：有自己的想法&lt;/h3&gt;&lt;p&gt;我是从大学才开始接触编程的，起点并没有比别人早。大一一个学期学完了C语言，发现单单学习C语言离做出自己的项目还差得远呢。当时就照着课程学习，没有自己的想法，但发现大学的学习还是那么的空，就开始有了自己的想法，有了点“叛逆”。我认为这是我进入大学的第一个里程碑。&lt;/p&gt;
&lt;p&gt;我觉得刚开始接触编程兴趣很重要，像之前学校教C语言的方式很容易让我们失去兴趣，另外要有直观的反馈而不是冷冰冰的终端，输出无聊的数字，除此之外还要有成就感，要有那种创造的感觉。&lt;/p&gt;
&lt;p&gt;于是，出于兴趣，我开始尝试学习 iOS 开发。最开始我是通过 Stanford University 的公开课 CS193p 和一些参考书籍学习 iOS 开发，但是这个过程很痛苦。&lt;/p&gt;
&lt;p&gt;第一点就是从面向过程到面向对象，当时没有学过面向对象，而且了解oc的人都知道oc的语法很奇葩，当时对我来说就是灾难。由于Xcode是英文的，当时很惧怕，完全不知道怎么用Xcode调试，遇到错误信息完全看不懂，也不知道怎么利用这些信息在网上查询。一遇到闪退这种情况束手无策，当时很傻，重看一遍课程重做一遍。这种做法其实是不对的，一定要找到你错误的根源。&lt;/p&gt;
&lt;p&gt;后来，学校里的一位老师找人做 iOS 项目，我自告奋勇报名参加。老师给了我一个 Android 的项目 Demo，让我做出 iOS 版的 demo，作为一个测试。在这个过程中，我逐渐学会了运用 Google、Stackoverflow 解决问题，学会了调试、改 bug，通过 git 来版本控制，代码规范等。这段时间内，我学到了很多东西。自己从0到1做项目所遇到的问题数量会远远高于照着教程做时遇到的问题，解决这些问题能使能力获得快速增长。&lt;strong&gt;Leaning by doing is the most effective learning method. &lt;/strong&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;里程碑二：不再惧怕英文&quot;&gt;&lt;a href=&quot;#里程碑二：不再惧怕英文&quot; class=&quot;headerlink&quot; title=&quot;里程碑二：不再惧怕英文&quot;&gt;&lt;/a&gt;里程碑二：不再惧怕英文&lt;/h3&gt;&lt;p&gt;这个过程开始慢慢的不在惧怕英文，这对我来说是第二个里程碑。我在学习iOS开发时，买过几本国人出的书，很厚，但是质量真的不高，看了这些书发现几乎没有效果，当我尝试着去看国外英文的文章，其文章质量真的高出不止一个档次。&lt;/p&gt;
&lt;p&gt;之后我常在 Ray Wenderlich (&lt;a href=&quot;http://www.raywenderlich.com)、objc.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.raywenderlich.com)、objc.io&lt;/a&gt; (&lt;a href=&quot;http://www.objc.io/)上看文章，读这两个网站出版的书籍。Ray&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.objc.io/)上看文章，读这两个网站出版的书籍。Ray&lt;/a&gt; Wenderlich上我前前后后看了11本书:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nero5023.github.io/images/ray_books.png&quot; alt=&quot;raybooks&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在看objc的这两本书&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nero5023.github.io/images/objc_books.png&quot; alt=&quot;objcbooks&quot;&gt;&lt;/p&gt;
&lt;p&gt;时间很快到了暑假，我觉得人都是有惰性的，我知道如果我待在家里一定是浪费时间，但是我就决定在暑假实习。在实习过程中独立完成了一个给客户演示的demo，出色的完成了任务，并获得这个公司的一份offer。&lt;/p&gt;
&lt;h3 id=&quot;里程碑三：接触在线教育&quot;&gt;&lt;a href=&quot;#里程碑三：接触在线教育&quot; class=&quot;headerlink&quot; title=&quot;里程碑三：接触在线教育&quot;&gt;&lt;/a&gt;里程碑三：接触在线教育&lt;/h3&gt;&lt;p&gt;当时觉得对学校里学的东西不感兴趣，就在在线教育平台上学习，Coursera和Udacity，Coursera课程种类多课程来自世界各地的名校，Udacity课程都是计算机课程，由硅谷工程师制作，我在Coursera上拿到了两个证书，在Udacity上付费学习了Full Stack Nanodegree。&lt;/p&gt;
&lt;h3 id=&quot;里程碑四：参加社区活动&quot;&gt;&lt;a href=&quot;#里程碑四：参加社区活动&quot; class=&quot;headerlink&quot; title=&quot;里程碑四：参加社区活动&quot;&gt;&lt;/a&gt;里程碑四：参加社区活动&lt;/h3&gt;&lt;p&gt;一次偶然的机会，我参加了Udacity 在上海举办的用户见面会，认识了Frank、Jade、Grant，通过他们了解到了GDG，了解到了社区的力量，之后我每周都参加GDG苏州的活动学到了很多，结交了很多朋友。社区的力量就在于你获得对一件事物的知识是一起参加活动的人对该事物的不同的理解而不是你一个人的。&lt;/p&gt;
&lt;h2 id=&quot;申请-Apple-WWDC-Scholarship&quot;&gt;&lt;a href=&quot;#申请-Apple-WWDC-Scholarship&quot; class=&quot;headerlink&quot; title=&quot;申请 Apple WWDC Scholarship&quot;&gt;&lt;/a&gt;申请 Apple WWDC Scholarship&lt;/h2&gt;&lt;p&gt;寒假时我开始准备参加 Apple WWDC Scholarship 的 app。由于我觉得做游戏更能发挥想象力，于是我决定做我从未尝试过的游戏。我选用了 Apple 的 SpriteKit 框架，但却在游戏的内容构思环节卡壳了……这使我深深体会到了灵感的重要性，灵感就是一个项目的源头，没有源头后面的都是空壳。&lt;/p&gt;
&lt;p&gt;我的灵感来源很偶然：当时盯着电脑前面墙发呆。&lt;br&gt;&lt;img src=&quot;http://nero5023.github.io/images/rodot_inspiration.jpg&quot; alt=&quot;inspriation&quot;&gt;&lt;/p&gt;
&lt;p&gt;突然灵感来了！将墙砖中间加小球，白色分界线看成棒，可以绕着墙砖的顶点旋转，并且给顶点加一些限制。我马上找来牙签在桌子上摆起来，经过实践，这个想法确实可行！随即我就开始做 demo了。&lt;/p&gt;
&lt;p&gt;我将分3个方面介绍我开发的过程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;游戏逻辑&lt;br&gt;这个一部分是最花时间的。其中遇到的一个困难是，当我想增加游戏内容时发现，如果扩展我原来的代码便会出现很多冗余代码。我使用 GameplayKit 的 Entity-Component 来重构代码，这个过程就是将具体化成抽象，花了一周左右，之后的游戏性拓展方便了许多。开发过程中遇到了一个又一个的问题，一个又一个的 bug，但都能通过不断调试、查阅文档、观看 WWDC 视频解决。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后台服务器&lt;br&gt;我的 app 有分享自己做的 level 的功能，这就需要有服务器。用到了之前在Udacity上学习Full Stack Nanodegree的知识。同时，要实现跳转到我的 app 的功能，就需要实现 Universal Links，需要配置域名和Https。在实践中，我实现了好多自己的“第一次”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;设计&lt;br&gt;设计是令我最头疼的地方。我没有学过设计，对配色什么的也一窍不通，只会用 Sketch 进行一些基本操作。在我设计游戏的过程中，我认为最难的地方在于如何在一个小的点上表示出3种信息：可旋转的棒的数目、可旋转次数、选择方向，并且要保持美观、直观、简洁。这整整花了我两天的时间。但是，在面对我们不熟悉的方面时，只要去尝试，总会有结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这个开发过程中感受最深的就是，我在不停地给自己创造问题，并靠自己不断地去分析问题、解决问题。  这里没有用遇到问题，而是用创造问题是因为遇到问题是被动的，创造问题是主动的，只有给自己不断地去创造问题，制造麻烦，提高要求，才能不断地完善。&lt;/p&gt;
&lt;p&gt;5月10日早上8点左右，我收到来自 Apple WWDC 的邮件。当时的心情并没有原来想象的那么激动。那3个月我花了几乎所有的业余时间用于设计开发，感觉这一切都是水到渠成的。&lt;/p&gt;
&lt;p&gt;在开发过程中，我当了次全栈工程设计师（自己创了个名词 ^__^，当然也远远没有达到这个水平），有一种满满的成就感。将自己的灵感用代码来实现的感觉，实在是令人欲罢不能！  &lt;/p&gt;
&lt;p&gt;对你而言最重要的事物一定比你想要得到的事物更早地出现在路边。&lt;/p&gt;
&lt;p&gt;现在我有了一个我自己在上线的app，我今后会去不断更新迭代它，此外我即将前往美国参加WWDC，我希望这两件事能成为我新的里程碑，继续改变我。&lt;/p&gt;
&lt;h2 id=&quot;APP&quot;&gt;&lt;a href=&quot;#APP&quot; class=&quot;headerlink&quot; title=&quot;APP&quot;&gt;&lt;/a&gt;APP&lt;/h2&gt;&lt;p&gt;我做的app名叫RoDot，这是下载链接 &lt;a href=&quot;https://appsto.re/us/LFRJbb.i&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://appsto.re/us/LFRJbb.i&lt;/a&gt;，有兴趣的下载一下，支持一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nero5023.github.io/images/rodot_icon.png&quot; alt=&quot;RoDot&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nero5023.github.io/images/rodot_qrcode.png&quot; alt=&quot;RoDotQR&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我现在是苏州大学计科院物联网工程大二的学生。在这篇文章中我将分享我学习 iOS 的历程，独立开发app并成功申请到 Apple WWDC Scholarship 的故事，以及一些个人感悟。&lt;/p&gt;
&lt;h2 id=&quot;学习历程&quot;&gt;&lt;a href=&quot;#学习历程&quot; class=&quot;headerlink&quot; title=&quot;学习历程&quot;&gt;&lt;/a&gt;学习历程&lt;/h2&gt;&lt;h3 id=&quot;里程碑一：有自己的想法&quot;&gt;&lt;a href=&quot;#里程碑一：有自己的想法&quot; class=&quot;headerlink&quot; title=&quot;里程碑一：有自己的想法&quot;&gt;&lt;/a&gt;里程碑一：有自己的想法&lt;/h3&gt;&lt;p&gt;我是从大学才开始接触编程的，起点并没有比别人早。大一一个学期学完了C语言，发现单单学习C语言离做出自己的项目还差得远呢。当时就照着课程学习，没有自己的想法，但发现大学的学习还是那么的空，就开始有了自己的想法，有了点“叛逆”。我认为这是我进入大学的第一个里程碑。&lt;/p&gt;
&lt;p&gt;我觉得刚开始接触编程兴趣很重要，像之前学校教C语言的方式很容易让我们失去兴趣，另外要有直观的反馈而不是冷冰冰的终端，输出无聊的数字，除此之外还要有成就感，要有那种创造的感觉。&lt;/p&gt;
&lt;p&gt;于是，出于兴趣，我开始尝试学习 iOS 开发。最开始我是通过 Stanford University 的公开课 CS193p 和一些参考书籍学习 iOS 开发，但是这个过程很痛苦。&lt;/p&gt;
&lt;p&gt;第一点就是从面向过程到面向对象，当时没有学过面向对象，而且了解oc的人都知道oc的语法很奇葩，当时对我来说就是灾难。由于Xcode是英文的，当时很惧怕，完全不知道怎么用Xcode调试，遇到错误信息完全看不懂，也不知道怎么利用这些信息在网上查询。一遇到闪退这种情况束手无策，当时很傻，重看一遍课程重做一遍。这种做法其实是不对的，一定要找到你错误的根源。&lt;/p&gt;
&lt;p&gt;后来，学校里的一位老师找人做 iOS 项目，我自告奋勇报名参加。老师给了我一个 Android 的项目 Demo，让我做出 iOS 版的 demo，作为一个测试。在这个过程中，我逐渐学会了运用 Google、Stackoverflow 解决问题，学会了调试、改 bug，通过 git 来版本控制，代码规范等。这段时间内，我学到了很多东西。自己从0到1做项目所遇到的问题数量会远远高于照着教程做时遇到的问题，解决这些问题能使能力获得快速增长。&lt;strong&gt;Leaning by doing is the most effective learning method. &lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="分享" scheme="http://yoursite.com/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="RoDot" scheme="http://yoursite.com/tags/RoDot/"/>
    
      <category term="WWDC" scheme="http://yoursite.com/tags/WWDC/"/>
    
      <category term="WWDC Scholarship" scheme="http://yoursite.com/tags/WWDC-Scholarship/"/>
    
  </entry>
  
</feed>
